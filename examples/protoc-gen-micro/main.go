package main

import (
	"fmt"
	"log"
	"strings"

	"github.com/dave/jennifer/jen"
	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/pubgo/xerror"
	"github.com/pubgo/xprotogen"
)

const (
	contextPkg     = "context"
	clientPkg      = "github.com/asim/go-micro/v3/client"
	serverPkg      = "github.com/asim/go-micro/v3/server"
	fmtPkg         = "fmt"
	gogoprotoPkg   = "github.com/gogo/protobuf/gogoproto"
	protoPkg       = "github.com/golang/protobuf/proto"
	annotationsPkg = "google.golang.org/genproto/googleapis/api/annotations"
	mathPkg        = "math"
)

func main() {
	defer xerror.Resp(func(err xerror.XErr) {
		fmt.Println(err.Stack(true))
	})

	m := xprotogen.New("micro")
	m.Parameter(func(key, value string) {
		log.Println("params:", key, "=", value)
	})

	m.Init(func(pkg string, fd *pb.FileDescriptorProto, j *jen.File) error {
		j.ImportAlias(fmtPkg, "fmt")
		j.ImportAlias(contextPkg, "context")
		j.ImportAlias(mathPkg, "math")
		j.Line()

		j.ImportAlias(clientPkg, "client")
		j.ImportAlias(serverPkg, "server")
		j.ImportAlias(gogoprotoPkg, "_")
		j.ImportAlias(protoPkg, "proto")
		j.ImportAlias(annotationsPkg, "_")

		j.PackageComment("// Code generated by protoc-gen-micro. DO NOT EDIT.")
		if fd.GetOptions().GetDeprecated() {
			j.PackageComment(fmt.Sprintln("// ", fd.GetName(), " is a deprecated file."))
		} else {
			j.PackageComment(fmt.Sprintln("// source: ", fd.GetName()))
		}
		j.Line()

		j.Comment("// Reference imports to suppress errors if they are not otherwise used.")
		j.Id("var _ =").Qual(protoPkg, "Marshal")
		j.Id("var _ =").Qual(fmtPkg, "Errorf")
		j.Id("var _ =").Qual(mathPkg, "Inf")
		j.Line()

		j.Comment("// This is a compile-time assertion to ensure that this generated file")
		j.Comment("// is compatible with the proto package it is being compiled against.")
		j.Comment("// A compilation error at this line likely means your copy of the")
		j.Comment("// proto package needs to be updated.")
		j.Line()

		j.Id("const _ = ").Qual(protoPkg, "ProtoPackageIsVersion3").Comment("// please upgrade the proto package")
		j.Line()

		j.Comment("// Reference imports to suppress errors if they are not otherwise used.")
		j.Id("var _ ").Qual(contextPkg, "Context")
		j.Id("var _ ").Qual(clientPkg, "Option")
		j.Id("var _ ").Qual(serverPkg, "Option")
		j.Line()

		return nil
	})

	xerror.Panic(m.Service(func(ss *xprotogen.Service) {
		j := ss.J
		srv := ss.Name
		srv1 := strings.ToLower(srv[:1]) + srv[1:]

		srvName := srv + "Service"
		srvName1 := srv1 + "Service"

		srvHandler := srv + "Handler"
		srvHandler1 := srv1 + "Handler"

		j.Comment(fmt.Sprintf("// Client API for %s service", srv))
		j.Type().Id(srvName).InterfaceFunc(func(group *jen.Group) {
			for _, m := range ss.GetMethod() {
				mthName := xprotogen.CamelCase(m.GetName())

				mthOpt, err := xprotogen.ExtractAPIOptions(m)
				xerror.Panic(err)

				method, path := xprotogen.ExtractHttpMethod(mthOpt)
				log.Println(srv, mthName, method, path)

				group.Id(mthName).Params(
					jen.Id("ctx ").Qual(contextPkg, "Context"),
					jen.Id("in *"+ss.TypeName(m.GetInputType())),
					jen.Id("opts ...").Qual(clientPkg, "CallOption"),
				).Params(jen.Id(ss.TypeName(m.GetOutputType())), jen.Error())
			}
		})

		j.Type().Id(srvName1).StructFunc(func(group *jen.Group) {
			group.Id("c").Qual(clientPkg, "Client")
			group.Id("name").String()
		})
		j.Line()

		j.Func().Id("New"+srvName).Params(
			jen.Id("name").String(),
			jen.Id("c").Qual(clientPkg, "Client"),
		).Id(srvName).Block(jen.Id(fmt.Sprintf(`return &%s{
		c:    c,
		name: name,
	}`, srvName1)))
		j.Line()

		for _, m := range ss.GetMethod() {
			mthName := xprotogen.CamelCase(m.GetName())
			j.Func().
				Params(jen.Id("c *").Id(srvName1)).Id(mthName).
				Params(
					jen.Id("ctx ").Qual(contextPkg, "Context"),
					jen.Id("in *"+ss.TypeName(m.GetInputType())),
					jen.Id("opts ...").Qual(clientPkg, "CallOption"),
				).
				Params(jen.Id(ss.TypeName(m.GetOutputType())), jen.Error()).BlockFunc(func(group *jen.Group) {
				group.Id(fmt.Sprintf(`req := c.c.NewRequest(c.name, "%s.%s", in)
out := new(%s)
err := c.c.Call(ctx, req, out, opts...)
if err != nil {
	return nil, err
}
return out, nil`, srv, mthName, srvName))
			})
			j.Line()
		}

		j.Comment("// Server API for TestApi service")
		j.Type().Id(srvHandler).InterfaceFunc(func(group *jen.Group) {
			for _, m := range ss.GetMethod() {
				mthName := xprotogen.CamelCase(m.GetName())
				group.Id(mthName).
					Params(
						jen.Qual(contextPkg, "Context"),
						jen.Id(ss.TypeName(m.GetInputType())),
						jen.Id(ss.TypeName(m.GetOutputType())),
					).
					Error()
			}
		})
		j.Line()

		j.Func().Id("Register"+srvHandler).
			Params(
				jen.Id("s").Qual(serverPkg, "Server"),
				jen.Id("hdlr").Id(srvHandler),
				jen.Id("opts ... ").Qual(serverPkg, "HandlerOption"),
			).Error().BlockFunc(func(group *jen.Group) {
			group.Type().Id(srvHandler1).InterfaceFunc(func(group *jen.Group) {
				for _, m := range ss.GetMethod() {
					mthName := xprotogen.CamelCase(m.GetName())
					group.Id(mthName).
						Params(
							jen.Qual(contextPkg, "Context"),
							jen.Id(ss.TypeName(m.GetInputType())),
							jen.Id(ss.TypeName(m.GetOutputType())),
						).
						Error()
				}
			})
			group.Type().Id(srv).Struct(jen.Id(srv1))
			group.Id(fmt.Sprintf("h := &%s{hdlr}", srvHandler1))
			group.Id(fmt.Sprintf("return s.Handle(s.NewHandler(&%s{h}, opts...))", srv))
		})
		j.Line()

		j.Type().Id(srvHandler1).Struct(jen.Id(srvHandler))
		j.Line()

		for _, m := range ss.GetMethod() {
			mthName := xprotogen.CamelCase(m.GetName())
			j.Func().
				Params(jen.Id("h *").Id(srvHandler1)).Id(mthName).
				Params(
					jen.Id("ctx ").Qual(contextPkg, "Context"),
					jen.Id("in *"+ss.TypeName(m.GetInputType())),
					jen.Id("out *"+ss.TypeName(m.GetOutputType())),
				).Error().Block(
				jen.Id(fmt.Sprintf("return h.%s.%s(ctx, in, out)", srvHandler, mthName)),
			)
			j.Line()
		}

	}))

	xerror.Panic(m.Save())
}
