package main

import (
	"github.com/dave/jennifer/jen"
	"github.com/pubgo/xerror"
	"github.com/pubgo/xprotogen/gen"
	"log"
)

func clientMethod(m *gen.Method) *jen.Statement {
	m.Set("mthName", m.GetName())
	m.Set("inType", m.GetInputType())
	m.Set("outType", m.GetOutputType())

	return jen.Id(m.GetName()).
		ParamsFunc(func(group *jen.Group) {
			group.Id("ctx context.Context")
			if !m.GetClientStreaming() {
				group.Id("in *" + m.GetInputType())
			}
			group.Id("opts ...client.CallOption")
		}).
		ParamsFunc(func(group *jen.Group) {
			outType := "*" + m.GetOutputType()
			if m.GetServerStreaming() || m.GetClientStreaming() {
				outType = m.Fmt("{{.srv}}_{{.mthName}}Service")
			}

			group.Id(outType)
			group.Error()
		})
}

func serverMethod(m *gen.Method) *jen.Statement {
	return jen.Id(m.GetName()).ParamsFunc(func(group *jen.Group) {
		group.Id("context.Context")
		if !m.GetClientStreaming() {
			group.Id("*" + m.GetInputType())
		}
		if m.GetServerStreaming() || m.GetClientStreaming() {
			group.Id(m.Fmt("{{.srv}}_{{.mthName}}Stream"))
		}
		if !m.GetClientStreaming() && !m.GetServerStreaming() {
			group.Id("*" + m.GetOutputType())
		}
	}).Error()
}

func serviceClient(m *gen.Method) *jen.Statement {
	m.Set("mthName", m.GetName())
	m.Set("inType", m.GetInputType())
	m.Set("outType", m.GetOutputType())
	m.Set("cs", m.GetClientStreaming())
	m.Set("ss", m.GetServerStreaming())

	j := m.P("func (c *{{.srvS}})").Add(clientMethod(m)).BlockFunc(func(group *jen.Group) {
		if !m.GetServerStreaming() && !m.GetClientStreaming() {
			group.Add(m.P(`
			req := c.c.NewRequest(c.name, "{{.srv}}.{{.mthName}}", in)
			out := new({{.outType}})
			err := c.c.Call(ctx, req, out, opts...)
			if err != nil {
				return nil, err
			}
			return out, nil`))
		} else {
			group.Add(m.P(`
			req := c.c.NewRequest(c.name, "{{.srv}}.{{.mthName}}", &{{.inType}}{})
			stream, err := c.c.Stream(ctx, req, opts...)
			if err != nil { return nil, err }`))
			if !m.GetClientStreaming() {
				group.Id("if err := stream.Send(in); err != nil { return nil, err }")
			}
			group.Add(m.P("return {{.srv}}.{{.mthName}}{stream}, nil"))
		}
	})

	j.Comment("// Stream auxiliary types and methods.")
	j.Add(m.P(`
	type {{.srv}}_{{.mthName}}Service interface {
	   Context() context.Context
	   SendMsg(interface{}) error
	   RecvMsg(interface{}) error
	   Close() error
	{{if .cs}}
		Send(*{{.inType}}) error
	{{end}}

	{{if .ss}}
		Recv(*{{.outType}}) error
	{{end}}
	}`))

	j.Add(m.P(` 
	type {{.srv}}{{.mthName}} struct {
        stream client.Stream
    }

    func (x *{{.srv}}{{.mthName}}) Close() error {
    	return x.stream.Close()
    }

    func (x *{{.srv}}{{.mthName}}) Context() context.Context {
    	return x.stream.Context()
    }

    func (x *{{.srv}}{{.mthName}}) SendMsg(m interface{}) error {
    	return x.stream.Send(m)
    }

    func (x *{{.srv}}{{.mthName}}) RecvMsg(m interface{}) error {
    	return x.stream.Recv(m)
    }

    func (x *{{.srv}}{{.mthName}}) Send(m *Message) error {
    	return x.stream.Send(m)
    }


    {{ if .cs }}
        func (x *{{.srv}}{{.mthName}}) Send(m *{{.inType}}) error{
            return x.stream.Send(m)
        }
    {{ end }}

    {{ if .ss }}
        func (x *{{.srv}}{{.mthName}}) Recv() (*{{.outType}}, error) {
            m := new({{.outType}})
            err := x.stream.Recv(m)
            if err != nil {
                return nil, err
            }
                return m, nil
        }
    {{ end }}`))

	return j
}

func main() {
	defer xerror.RespDebug()

	m := gen.New("micro")
	m.Parameter(func(key, value string) {
		log.Println("params:", key, "=", value)
	})

	xerror.Panic(m.Init(func(fd *gen.FileDescriptor) {
		var (
			j = fd.J
		)

		j.PackageComment("// Code generated by protoc-gen-micro. DO NOT EDIT.")
		if !fd.GetOptions().GetDeprecated() {
			j.PackageComment("// source: " + fd.GetName())
		} else {
			j.PackageComment("// " + fd.GetName() + " is a deprecated file.")
		}

		j.Id(`
    import (
    	fmt "fmt"
    	math "math"
    	context "context"

        client "github.com/asim/go-micro/v3/client"
    	server "github.com/asim/go-micro/v3/server"
    	_ "github.com/gogo/protobuf/gogoproto"
    	proto "github.com/golang/protobuf/proto"
    	_ "google.golang.org/genproto/googleapis/api/annotations"
    )

    // Reference imports to suppress errors if they are not otherwise used.
    var _ = proto.Marshal
    var _ = fmt.Errorf
    var _ = math.Inf

    // This is a compile-time assertion to ensure that this generated file
    // is compatible with the proto package it is being compiled against.
    // A compilation error at this line likely means your copy of the
    // proto package needs to be updated.
    const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

    // Reference imports to suppress errors if they are not otherwise used.
    var _ context.Context
    var _ client.Option
    var _ server.Option`)

		for _, ss := range fd.GetService() {
			var (
				pkg  = ss.Pkg
				srv  = ss.GetName()
				srv1 = gen.UnExport(ss.GetName())
			)

			ss.Set("pkg", pkg)
			ss.Set("srv", srv)
			ss.Set("srvS", srv+"Service")
			ss.Set("srvH", srv+"Handler")
			ss.Set("srv1", srv1)
			ss.Set("srvS1", srv1+"Service")
			ss.Set("srvH1", srv1+"Handler")
			Service(ss)
		}
	}))
}

func serviceServer(m *gen.Method) *jen.Statement {
	m.Set("mthName", m.GetName())
	m.Set("inType", m.GetInputType())
	m.Set("outType", m.GetOutputType())
	m.Set("cs", m.GetClientStreaming())
	m.Set("ss", m.GetServerStreaming())
	m.Set("serveType", m.Fmt("{{.srv}}Handler"))
	m.Set("streamType", m.Fmt("{{.srv1}}{{.mthName}}Stream"))

	return m.P(`
	{{ if and (not .ss) (not .cs) }}
        func (h *{{.srv}}Handler){{.mthName}}(ctx context.Context, in *{{.inType}}, out *{{.outType}}) error {
    		return h.{{.serveType}}.{{.mthName}}(ctx, in, out)
        }
    {{ end }}

    func (h *{{.srv}}Handler){{.mthName}}(ctx context.Context, stream server.Stream) error {
        {{ if not .cs }}
            m := new({{.inType}})
            if err := stream.Recv(m); err != nil { return err }
            return h.{{.serveType}}.{{.mthName}}(ctx, m, &{{.streamType}}{stream})
        {{ else }}
            return h.{{.serveType}}.{{.mthName}}(ctx, &{{.streamType}}{stream})
        {{ end }}
    }

    type {{.srv}}_{{.mthName}}Stream interface {
        Context() context.Context
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        {{ if .ss }}
            Send(*{{.outType}}) error
        {{ end }}

        {{ if .cs }}
            Recv() (*{{.inType}}, error)
        {{ end }}
    }

    type {{.streamType}} struct {
        stream server.Stream
    }


    func (x *{{.streamType}}) Close() error {
    	return x.stream.Close()
    }

    func (x *{{.streamType}}) Context() context.Context {
    	return x.stream.Context()
    }

    func (x *{{.streamType}}) SendMsg(m interface{}) error {
    	return x.stream.Send(m)
    }

    func (x *{{.streamType}}) RecvMsg(m interface{}) error {
    	return x.stream.Recv(m)
    }

    {{ if .ss }}
        func (x *{{.streamType}}) Send(*{{.outType}}) error {
            return x.stream.Send(m)
        }
    {{ end }}

    {{ if .cs }}
        func (x *{{.streamType}}) Recv() (*{{.inType}}, error) {
            m := new({{.inType}})
            if err := x.stream.Recv(m); err != nil { return nil, err }
            return m, nil
        }
    {{ end }}`)
}

func Service(ss *gen.Service) {
	j := ss.J
	j.Comment(ss.Fmt("// Client API for {{.srv}} service"))
	j.Add(ss.P("type {{.srvS}} interface").BlockFunc(func(group *jen.Group) {
		for _, m := range ss.GetMethod() {
			group.Add(clientMethod(m))
		}
	}))
	j.Add(ss.P(`
	type {{.srvS1}} struct {
			c    client.Client
			name string
	}
	
	func New{{.srvS}}(name string, c client.Client) {{.srv}}Service {
        return &{{.srv1}}Service{
            c:    c,
            name: name,
        }
    }`))

	for _, m := range ss.GetMethod() {
		j.Add(serviceClient(m))
	}

	j.Comment(ss.Fmt("// Server API for {{.srv}} service"))
	j.Add(ss.P("type {{.srv}}Handler interface").BlockFunc(func(group *jen.Group) {
		for _, m := range ss.GetMethod() {
			group.Add(serverMethod(m))
		}
	}))

	j.Add(ss.P("func Register{{.srv}}Handler(s server.Server, hdlr {{.srv}}Handler, opts ...server.HandlerOption) error").BlockFunc(func(group *jen.Group) {
		group.Add(ss.P(`type {{.srv1}} interface`).BlockFunc(func(group *jen.Group) {
			for _, m := range ss.GetMethod() {
				m.Set("mthName", m.GetName())
				m.Set("inType", m.GetInputType())
				m.Set("outType", m.GetOutputType())
				m.Set("cs", m.GetClientStreaming())
				m.Set("ss", m.GetServerStreaming())
				m.Set("serveType", m.Fmt("{{.srv}}Handler"))
				m.Set("streamType", m.Fmt("{{.srv1}}{{.mthName}}Stream"))

				if !m.GetServerStreaming() && !m.GetClientStreaming() {
					group.Add(ss.P("{{.mthName}}(ctx context.Context,in *{{.inType}},out *{{.outType}}) error"))
					continue
				}
				group.Add(ss.P("{{.mthName}}(ctx context.Context,stream server.Stream)error"))
			}
		}))

		group.Add(ss.P(`
		type {{.srv}} struct {
            {{.srv1}}
        }
        h := &{{.srv1}}Handler{hdlr}
        return s.Handle(s.NewHandler(&{{.srv}}{h}, opts...))`))
	}))

	j.Add(ss.P(`
	type {{.srv1}}Handler struct {
        {{.srv}}Handler
    }`))

	for _, m := range ss.GetMethod() {
		j.Add(serviceServer(m))
	}

	for _, m := range ss.GetMethod() {
		method, path := m.GetHttpMethod()
		j.Comment("//").Id(method).Id(path)
	}
}
